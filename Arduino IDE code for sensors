/*update 7/25: added median filtering with bubble sort for a more stable voltage input for the ph and tds sensors 
added condition for sensor readins = nan and/or inf, all should be numeric or else data cant parse to servers 
https://wiki.dfrobot.com/Gravity__Analog_TDS_Sensor___Meter_For_Arduino_SKU__SEN0244?utm_source=chatgpt.com
*/

//libraries
#include <OneWire.h>               
#include <DallasTemperature.h>    
#include <DHT.h>                   
#include <WiFi.h>
#include <PubSubClient.h>
#include <cmath>

//network setup through pi
const char* ssid = "PUHFHUB";
const char* password = "PUHF200!";
const char* mqtt_server = "192.168.4.1";
WiFiClient espClient;
PubSubClient client(espClient);

//pump timing. max 1 min
unsigned long pumpstarttime = 0; 
bool pumprunning = false; 
const unsigned long maxpumptime = 30000; 

//pin locations
#define DHTPIN 33                 
#define DHTTYPE DHT11                           
#define ONE_WIRE_BUS 15            
#define TDS_PIN 34
#define PH_PIN 35
#define FLOAT_PIN 27

// sensor objects
DHT dht(DHTPIN, DHTTYPE);
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

// for pump, will have to change to ppm later
const int tdslow = 1500;           // µS/cm
const int tdshigh = 4000;          // µS/cm

//median filter setup with arrays
#define SCOUNT 30

int phBuffer[SCOUNT];
int phBufferTemp[SCOUNT];
int phBufferIndex = 0;

int tdsBuffer[SCOUNT];
int tdsBufferTemp[SCOUNT];
int tdsBufferIndex = 0;

//reconnection loop for mqtt
void reconnect(){ 
  while (!client.connected()){
    Serial.print("Attempting MQTT connection...");
    if (client.connect("ESP32Client")){
      Serial.println("connected");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      delay(2000);
    }
  }
}

int getMedian(int arr[], int len); 

void setup() {
  //force the pump off until i figure out tds lol
  pinMode(25, OUTPUT);
  pinMode(26, OUTPUT);
  digitalWrite(25, LOW);
  digitalWrite(26, LOW);
  //start sensor reads
  Serial.begin(9600);
  dht.begin();           
  sensors.begin();  
  pinMode(FLOAT_PIN, INPUT_PULLUP);

  //voltage readings for analogs
  analogReadResolution(12); // 12-bit Espressif official docs
  analogSetAttenuation(ADC_11db); // allows full-scale voltage up from Espressif official docs

  //pump pins, all turned off first
  pinMode(25, OUTPUT);
  pinMode(26, OUTPUT);
  digitalWrite(25, LOW);
  digitalWrite(26, LOW);

  // connect to wifi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi...");
  while (WiFi.status() != WL_CONNECTED){
    delay(1000);
    Serial.print(".");
  }
  Serial.println("WiFi Connected");
  Serial.println(WiFi.localIP());

  //connect to mosquitto with pi
  client.setServer(mqtt_server, 1883);
  reconnect();
}

void loop() {
  if (!client.connected()) reconnect(); //if not connected to mqtt, reconnect loop
  client.loop(); //active client 

  // water temp
  sensors.requestTemperatures();
  float waterTemp = sensors.getTempCByIndex(0);
  if (isnan(waterTemp) || isinf (waterTemp)) waterTemp = 0.0;

  // room conditions
  float humidity = dht.readHumidity();
  if (isnan(humidity) || isinf (humidity)) humidity = 0.0;


  float temperature = dht.readTemperature();
  if (isnan(temperature)) temperature = 0.0;
  if (isnan(temperature) || isinf (temperature)) temperature = 0.0;

  //float sens
  int floatstate = digitalRead(FLOAT_PIN);

  //median filter loop
  phBuffer[phBufferIndex++] = analogRead(PH_PIN);
  if (phBufferIndex >= SCOUNT) phBufferIndex = 0; 

  tdsBuffer[tdsBufferIndex++] = analogRead(TDS_PIN);
  if (tdsBufferIndex >= SCOUNT) tdsBufferIndex = 0; 

  static unsigned long lastMedianCalc = 0;
  if (millis() - lastMedianCalc > 800) {
    lastMedianCalc = millis();

    // Copy buffers for sorting
    memcpy(phBufferTemp, phBuffer, sizeof(phBuffer));
    memcpy(tdsBufferTemp, tdsBuffer, sizeof(tdsBuffer));

    // Get median ADC readings
    int phMedianRaw = getMedian(phBufferTemp, SCOUNT);
    int tdsMedianRaw = getMedian(tdsBufferTemp, SCOUNT);

    // Convert median ADC to voltage
    float phVoltage = phMedianRaw * (3.3 / 4095.0);
    float tdsVoltage = tdsMedianRaw * (3.3 / 4095.0);

    float ph = (phVoltage - 1.65) / -0.059 + 7.0;
    if (isnan(ph) || isinf (ph)) ph = 0.0;

    

    float calibratedtds = 0.0;
    if (tdsMedianRaw < 10 || tdsMedianRaw > 4000) {
      // Treat as invalid / sensor in air
      calibratedtds = 0.0;
    } else {
      calibratedtds = tdsVoltage * (1000.0 / 2.3); //from DQrobot's page, it's not 3.3!
    }
    if (isnan(calibratedtds) || isinf (calibratedtds)) calibratedtds = 0.0;

    //live sensor reads publish payloads 
    String payload = "{";
    payload += "\"room_temp\":" + String(temperature) + ",";
    payload += "\"humidity\":" + String(humidity) + ",";
    payload += "\"water_temp\":" + String(waterTemp) + ",";
    payload += "\"tds\":" + String(calibratedtds, 1) + ",";
    payload += "\"ph\":" + String(ph, 2) + ",";
    payload += "\"low_water\":" + String(floatstate == LOW ? 1 : 0);
    payload += "}";
    client.publish("sensors/all", payload.c_str(), true);
    Serial.println(payload);


  Serial.print("TDS Voltage: "); Serial.println(tdsVoltage, 2);
  Serial.print("pH Voltage: "); Serial.println(phVoltage, 2);

    //pump, use gpio directly, add max time for 3 mins, off for 1, back on if needed

    unsigned long currenttime = millis();

    if (calibratedtds >= 1000 && calibratedtds < tdslow) {
      if (!pumprunning) {
        digitalWrite(25, HIGH);
        digitalWrite(26, LOW);
        pumpstarttime = currenttime;
        pumprunning = true; 
      } else if (currenttime - pumpstarttime >= maxpumptime) {
        digitalWrite(25, LOW);
        digitalWrite(26, LOW);
        pumprunning = false;
      }
    } else {
      if (pumprunning){
        digitalWrite(25, LOW);
        digitalWrite(26, LOW);
        pumprunning = false;
      } else {
        digitalWrite(25, LOW);
        digitalWrite(26, LOW);
      }
    }
  }
  // prints, for serial monitor - prototype only 
  Serial.println();
  delay(5000);
}

int getMedian(int arr[], int len) {
  // Simple bubble sort for median filtering from CQrobot wikipedia
  for (int i = 0; i < len - 1; i++) {
    for (int j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr[len / 2];  // middle value after sorting
}
